<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simplified English Translator</title>
  <style>
    :root {
      --bg1: #0c1c2f;
      --bg2: #0f2740;
      --panel: #0f2034;
      --accent: #f59e0b;
      --muted: #cbd5e1;
      --ink: #e2e8f0;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      font-family: "EB Garamond", "Palatino Linotype", "Book Antiqua", "Segoe UI", sans-serif;
      background:
        radial-gradient(circle at 20% 20%, rgba(20, 54, 90, 0.6), rgba(12, 28, 47, 0.2) 40%),
        linear-gradient(135deg, var(--bg1), var(--bg2));
      color: var(--ink);
      display: flex;
      justify-content: center;
      padding: 26px 18px 42px;
    }
    .page {
      width: min(1000px, 100%);
      background: rgba(15, 32, 52, 0.82);
      border: 1px solid rgba(255, 255, 255, 0.07);
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.35);
      overflow: hidden;
    }
    header {
      padding: 22px 26px 16px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      background: linear-gradient(115deg, rgba(245, 158, 11, 0.18), transparent 60%);
    }
    h1 { margin: 0; font-size: 26px; letter-spacing: 0.3px; }
    .subtitle { margin: 8px 0 0; color: var(--muted); line-height: 1.6; }
    .content { padding: 24px 26px 28px; display: grid; gap: 16px; }
    .panel {
      background: var(--panel);
      border-radius: 12px;
      padding: 14px 16px;
      border: 1px solid rgba(255, 255, 255, 0.06);
    }
    textarea {
      width: 100%;
      min-height: 140px;
      padding: 12px 14px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(255, 255, 255, 0.04);
      color: var(--ink);
      font-size: 15px;
      outline: none;
      resize: vertical;
    }
    .label { font-weight: 700; font-size: 14px; margin-bottom: 8px; display: block; }
    .status { color: var(--muted); font-size: 13px; }
    .output {
      min-height: 140px;
      white-space: pre-wrap;
      word-break: break-word;
      padding: 12px 14px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.03);
      color: var(--ink);
      font-size: 15px;
    }
    .muted { color: var(--muted); font-size: 14px; }
  </style>
</head>
<body>
  <main class="page" aria-label="Simplified English translator">
    <header>
      <h1>Simplified English Translator</h1>
      <p class="subtitle">
        Type or paste traditional English. As you type, the page uses CMU pronunciations to produce a shorter spelling.
        Unknown words stay unchanged. Only the translation and a short status are shown—no extra panels.
      </p>
    </header>

    <section class="content">
      <div class="panel">
        <label class="label" for="inputArea">Enter text</label>
        <textarea id="inputArea" placeholder="Example: The neighborhood brought weighty sacks through the thorough fair."></textarea>
        <div id="status" class="status" aria-live="polite">Loading CMU…</div>
      </div>

      <div class="panel">
        <label class="label">Translated</label>
        <div id="outputArea" class="output"></div>
      </div>

      <div class="muted">
        Notes: Uses CMU pronunciations (CMU.txt). If CMU is unavailable, a small built-in lexicon is used. Processing is client-side.
      </div>
    </section>
  </main>

  <script>
    const phonemeMap = {
      "AA": "a", "AE": "a", "AH": "a", "AO": "o", "AW": "ow", "AY": "ai",
      "B": "b", "CH": "ch", "D": "d", "DH": "th", "EH": "e", "ER": "ur",
      "EY": "ay", "F": "f", "G": "g", "HH": "h", "IH": "i", "IY": "ee",
      "JH": "j", "K": "k", "L": "l", "M": "m", "N": "n", "NG": "ng",
      "OW": "o", "OY": "oy", "P": "p", "R": "r", "S": "s", "SH": "sh",
      "T": "t", "TH": "th", "UH": "oo", "UW": "oo", "V": "v", "W": "w",
      "Y": "y", "Z": "s", "ZH": "zh"
    };

    const vowelSet = new Set(["AA","AE","AH","AO","AW","AY","EH","ER","EY","IH","IY","OW","OY","UH","UW"]);
    const forcedOverride = new Map([["the","tha"]]);
    const fallbackLexicon = new Map([
      ["weight", ["W","EY","T"]],
      ["sacks", ["S","AE","K","S"]],
      ["thorough", ["TH","ER","OW"]],
      ["through", ["TH","R","UW"]],
      ["neighborhood", ["N","EY","B","ER","HH","UH","D"]],
      ["transmission", ["T","R","AE","N","S","M","IH","SH","AH","N"]],
      ["brought", ["B","R","AO","T"]],
      ["gray", ["G","R","EY"]],
      ["color", ["K","AH","L","ER"]],
      ["attacker", ["AH","T","AE","K","ER"]]
    ]);
    const complexPattern = /(ough|eigh|igh|our|gue|que|eau|sion|tion|ph)/;

    function basePhoneme(p) { return (p || "").replace(/[0-9]/g, ""); }
    function isVowel(p) { return vowelSet.has(basePhoneme(p)); }

    function phonemesToSimplified(phonemes) {
      const segments = [];
      let notes = [];
      let addFinalE = false;

      const push = (text, type, note) => {
        segments.push({ text, type });
        if (note) notes.push(note);
      };

      for (let i = 0; i < phonemes.length; i++) {
        const curr = basePhoneme(phonemes[i]);
        const next = basePhoneme(phonemes[i + 1]);

        if (curr === "K" && next === "S") {
          push("x", "cons", "k+s → x");
          i += 1;
          continue;
        }
        if (curr === "EY") {
          if (i === phonemes.length - 2 && !isVowel(next)) {
            push("a", "vowel", "final EY → a·e");
            addFinalE = true;
          } else {
            push("ay", "vowel");
          }
          continue;
        }
        if (curr === "ER") {
          if (next === "HH") {
            push("or", "vowel", "er before h → or");
          } else {
            push("ur", "vowel");
          }
          continue;
        }
        if (curr === "AH" && next === "N" && i === phonemes.length - 2) {
          push("i", "vowel", "final AH N → in");
          continue;
        }
        if (curr === "UH") {
          push("oo", "vowel");
          continue;
        }
        const mapped = phonemeMap[curr] || curr.toLowerCase();
        push(mapped, isVowel(curr) ? "vowel" : "cons");
      }

      let spelling = "";
      for (const seg of segments) {
        if (spelling && seg.type === "cons") {
          const last = spelling[spelling.length - 1];
          if (seg.text[0] === last) {
            let trimmed = seg.text;
            while (trimmed.startsWith(last)) trimmed = trimmed.slice(1);
            spelling += trimmed;
            continue;
          }
        }
        spelling += seg.text;
      }
      if (addFinalE && !spelling.endsWith("e")) spelling += "e";
      return { spelling, notes };
    }

    function loadCMU() {
      const statusEl = document.getElementById("status");
      return fetch("CMU.txt")
        .then(res => {
          if (!res.ok) throw new Error("Fetch failed");
          return res.text();
        })
        .then(text => {
          const map = new Map();
          text.split(/\r?\n/).forEach(line => {
            if (!line.trim() || line.startsWith(";;;")) return;
            const parts = line.trim().split(/\s+/);
            if (parts.length < 2) return;
            const word = parts[0].toLowerCase().replace(/\(\d+\)$/, "");
            if (!map.has(word)) map.set(word, parts.slice(1));
          });
          statusEl.textContent = `CMU loaded (${map.size.toLocaleString()} entries)`;
          return map;
        })
        .catch(() => {
          statusEl.textContent = "Using built-in mini lexicon (CMU not loaded)";
          return fallbackLexicon;
        });
    }

    function matchCase(original, simplified) {
      if (original.toUpperCase() === original) return simplified.toUpperCase();
      if (original[0] === original[0].toUpperCase()) return simplified[0].toUpperCase() + simplified.slice(1);
      return simplified;
    }

    function simplifyWord(word, dict) {
      const key = word.replace(/[^A-Za-z']+/g, "").toLowerCase();
      if (!key) return word;
      if (forcedOverride.has(key)) return matchCase(word, forcedOverride.get(key));

      const phonemes = dict.get(key) || dict.get(key.replace(/'s$/, "")) || fallbackLexicon.get(key);
      if (!phonemes) return word; // unknown

      const { spelling, notes } = phonemesToSimplified(phonemes);
      const shouldChange = notes.length > 0 || complexPattern.test(key);
      const finalSpelling = shouldChange ? spelling : word.toLowerCase();
      return matchCase(word, finalSpelling);
    }

    function modernizeText(text, dict) {
      return text.replace(/[A-Za-z']+/g, (tok) => simplifyWord(tok, dict));
    }

    async function init() {
      const dict = await loadCMU();
      const input = document.getElementById("inputArea");
      const output = document.getElementById("outputArea");
      const render = () => {
        output.textContent = modernizeText(input.value, dict);
      };
      input.addEventListener("input", render);
      input.value = "The neighborhood brought weighty sacks through the thorough fair.";
      render();
    }

    init();
  </script>
</body>
</html>
